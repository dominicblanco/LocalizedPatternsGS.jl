#Computer assisted proof of solutions for the 2D Gray Scott system of equations
# Œª‚ÇÅŒîu‚ÇÅ - u‚ÇÅ + (u‚ÇÇ + 1 - Œª‚ÇÅu‚ÇÅ)u‚ÇÅ¬≤ = 0
# Œîu‚ÇÇ - Œª‚ÇÇu‚ÇÇ + (Œª‚ÇÅŒª‚ÇÇ - 1)u‚ÇÅ = 0
# The following code computes the solution and rigorously proves the results given in section 6 of
# "The 2D Gray-Scott sysem of equations: constructive proofs of existence of localized stationary patterns"  M. Cadiot and D. Blanco

# We computed the approximate solution using continuation. We provide the data here.
# From this we can check if the proof of the solution is verified or not. We essentially prove Theorems 6.1, 6.2, 6.3, and 6.4.

#####################################################################################################################################################################

# Needed packages
using RadiiPolynomial, IntervalArithmetic, IntervalLinearAlgebra, LinearAlgebra, JLD2

# Needed additional sequence structures for RadiiPolynomial (see Section 6)
# You can download this file from Github and put it in the same folder as this one. Then, it will include automatically.
include("D4Fourier.jl")

#####################################################################################################################################################################


#################################### List of the needed functions : go directly to line 245 for the main code ################################################# 

# Œ±‚Çô for the trace operator (see Section 3.2).
function Œ±‚Çô(n)
    if n[1] == n[2] == 0
        return 1
    elseif n[1] == n[2] != 0
        return 4
    elseif (n[1] != 0) & (n[2] == 0)
        return 2
    else
        return 4
    end
end

# Computes the trace for a D‚ÇÑFourier sequence.
function _trace_D‚ÇÑ(N)
    M = dimension(D‚ÇÑFourier(N,1.0))
    S = zeros(N+1,M)
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = 0:N
            m = (max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))
            Œ± = Œ±‚Çô(m)
            S[n‚ÇÅ+1,m[1] + m[2]*N - div(((m[2]-2)^2 + 3*(m[2]-2)),2)] = Œ±*(-1)^n‚ÇÇ
        end
    end
    return S
end

# Allows us to switch between D‚ÇÑ and exponential Fourier series
function _exp2D‚ÇÑ!(D::Vector{Float64},s::D‚ÇÑFourier)
    k = 1
    ord = order(s)[1]
    for k‚ÇÇ = 0:ord
        for k‚ÇÅ = k‚ÇÇ:ord
            if k‚ÇÅ == k‚ÇÇ == 0
                D[k] = 1
                k += 1
            elseif k‚ÇÅ == k‚ÇÇ != 0
                D[k] = sqrt(4)
                k += 1
            elseif (k‚ÇÅ != 0) & (k‚ÇÇ == 0)
                D[k] = sqrt(4)
                k += 1
            else
                D[k] = sqrt(8)
                k +=1 
            end
        end
    end
    return D
end

# Allows us to switch between D‚ÇÇ and exponential Fourier series
function exp2cos(N)

    d = 2*((ones((N+1)^2)))

    d[1] = 1;
    for n2=1:N
        d[n2+1] = sqrt(2);
    end

    for n1 = 1:N
        d[n1*(N+1)+1] = sqrt(2);
    end

    return d
end

# Computes convolution of D‚ÇÑFourier sequences up to order N
function _conv_small(u,v,N)
    #Computes u*v only up to order N
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(D‚ÇÑFourier(N,frequency(u)[1]), interval.(zeros(dimension(D‚ÇÑFourier(N,frequency(u)[1])))))
    for i‚ÇÇ ‚àà 0:N
        for i‚ÇÅ ‚àà i‚ÇÇ:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (max(abs(j‚ÇÅ),abs(j‚ÇÇ)),min(abs(j‚ÇÅ),abs(j‚ÇÇ)))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Performs convolution up to order N of a D‚ÇÑ and D‚ÇÇ Fourier series
function __conv_small(u,v,N)
    #Computes u*v up to order N
    #u is a sequence in D‚ÇÑFourier
    #v is a sequence in CosFourier ‚äó CosFourier (D‚ÇÇ symmetric)
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(CosFourier(N,frequency(u)[1])‚äóCosFourier(N,frequency(u)[1]), interval.(zeros((N+1)^2)))
    for i‚ÇÅ ‚àà 0:N
        for i‚ÇÇ ‚àà 0:N
            C·µ¢ = interval(zero(Float64))
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (abs(j‚ÇÅ),abs(j‚ÇÇ))
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Computes convolution of D‚ÇÑFourier sequences up to order N
function _conv_smallbig(u,v,N)
    #Computes u*v only up to order N
    order_u = order(space(u))[1]
    order_v = order(space(v))[1]
    C = Sequence(D‚ÇÑFourier(N,frequency(u)[1]), interval.(big.(zeros(dimension(D‚ÇÑFourier(N,frequency(u)[1]))))))
    for i‚ÇÇ ‚àà 0:N
        for i‚ÇÅ ‚àà i‚ÇÇ:N
            C·µ¢ = interval(zero(BigFloat))
            setprecision(80)
            @inbounds @simd for j‚ÇÅ ‚àà max(i‚ÇÅ-order_u, -order_v):min(i‚ÇÅ+order_u, order_v)
                @inbounds for j‚ÇÇ ‚àà max(i‚ÇÇ-order_u, -order_v):min(i‚ÇÇ+order_u, order_v)
                    tu = (max(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)),min(abs(i‚ÇÅ-j‚ÇÅ),abs(i‚ÇÇ-j‚ÇÇ)))
                    tv = (max(abs(j‚ÇÅ),abs(j‚ÇÇ)),min(abs(j‚ÇÅ),abs(j‚ÇÇ)))
                    setprecision(80)
                    C·µ¢ += u[tu] * v[tv]
                end
            end
            C[(i‚ÇÅ,i‚ÇÇ)] = C·µ¢
        end
    end
    return C
end

# Performs the estimate of Lemma 4.1
function œÜ(A,B,C,D)
    O‚ÇÅ = max(A,D) + max(B,C)
    O‚ÇÇ = sqrt(A^2 + D^2 + B^2 + C^2)
    return min(O‚ÇÅ,O‚ÇÇ)
end

# Computes the Fourier coefficients of 1_ùíü‚ÇÄ¬≤
function _char_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f)‚äóFourier(N,f), Interval.(complex.(big.(zeros((2N+1)^2)))))
    for n‚ÇÇ = -N:N
        for n‚ÇÅ = -N:N
            char[(n‚ÇÅ,n‚ÇÇ)] = interval(big(1))/(interval(big(4))*d^2) * exp(1im*n‚ÇÅ*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1))))*exp(1im*n‚ÇÇ*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1)))) * sinc(n‚ÇÅ/d*interval(big(1/2)))*sinc(n‚ÇÇ/d*interval(big(1/2)))
        end
    end
    rchar = Sequence(D‚ÇÑFourier(N,f), interval.(big.(zeros(dimension(D‚ÇÑFourier(N,f))))))
    for n‚ÇÇ = 0:N
        for n‚ÇÅ = n‚ÇÇ:N
            rchar[(n‚ÇÅ,n‚ÇÇ)] = real(char[(n‚ÇÅ,n‚ÇÇ)] + char[(n‚ÇÇ,-n‚ÇÅ)] + char[(-n‚ÇÅ,-n‚ÇÇ)] + char[(-n‚ÇÇ,n‚ÇÅ)])
        end
    end
    return rchar
end

# Computes the sequence a(d,‚ãÖ) for a in D‚ÇÑFourier.
function _sequence_on_boundary(a)
    N = order(a)[1]
    f = frequency(a)[1]
    anew = Sequence(CosFourier(N,f), interval.(big.(zeros(N+1))))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = -N:N
            anew[n‚ÇÅ] += a[(max(n‚ÇÅ,abs(n‚ÇÇ)),min(n‚ÇÅ,abs(n‚ÇÇ)))]*(-1)^n‚ÇÇ
        end
    end
    return anew
end

# Computes the Fourier coefficients of 1_ùíü‚ÇÄ
function _char_1D_boundary_coeffs(N,f,d)
    char = Sequence(Fourier(N,f), Interval.(complex.(big.(zeros((2N+1))))))
    for n = -N:N
        char[n] = interval(big(1))/(interval(big(2))*d) * exp(1im*n*interval(big(œÄ))*(interval(big(1))/d * interval(big(1/2)) - interval(big(1)))) * sinc(n/d*interval(big(1/2)))
    end
    rchar = Sequence(CosFourier(N,f), interval.(big.(zeros(N+1))))
    for n = 0:N
        rchar[n] = real(char[n] + char[-n])
    end
    return rchar
end

# Computes the function needed to take the convolution with ‚àÇ‚Çì‚ÇÅV‚ÇÅ·¥∫
# We denote by (·πº‚±º)‚Çò = |mÃÉ‚ÇÅ| (V‚±º·¥∫)‚Çò 
function _·πº‚±º_coeffs(V‚±º·¥∫)
    N = order(V‚±º·¥∫)[1]
    f = frequency(V‚±º·¥∫)[1]
    ·πº‚±º = Sequence(CosFourier(N,f)‚äóCosFourier(N,f), interval.(big.(zeros((N+1)^2))))
    for n‚ÇÅ = 0:N
        for n‚ÇÇ = 0:N
            ·πº‚±º[(n‚ÇÅ,n‚ÇÇ)] = abs(n‚ÇÅ)*f*V‚±º·¥∫[(max(n‚ÇÅ,n‚ÇÇ),min(n‚ÇÅ,n‚ÇÇ))]
        end
    end
    return ·πº‚±º
end

# Checks the conditions of the Radii-Polynomial Theorem 3.1.
function CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ,ùíµ‚ÇÇ,r‚ÇÄ)
    if ùíµ‚ÇÅ + ùíµ‚ÇÇ*r‚ÇÄ < 1
        if interval(1/2)*ùíµ‚ÇÇ*r‚ÇÄ^2 - (interval(1)-ùíµ‚ÇÅ)*r‚ÇÄ + ùí¥‚ÇÄ < 0
          display("The proof was successful for r‚ÇÄ = ")
          display(sup(r‚ÇÄ))  
        else
          display("The condition 2ùí¥‚ÇÄ*ùíµ‚ÇÇ < (1-ùíµ‚ÇÅ)¬≤ is not satisfied")
        end
    else
        if ùíµ‚ÇÅ > 1
            display("ùíµ‚ÇÅ is too big")
        else
          display("failure: linear term is positive")
        end
      end
end

################### PROOF OF SOLUTIONS : MAIN CODE #################################################################################################################################################
# To run the code, click the run button in the terminal.
# Below is the data for three solutions. To prove one of them, comment the others. 
# You can write a comment using the # sign. To comment multiple lines, use #= and end the comment with =#.
# Make sure to download the necessary file that includes the data you wish to prove!
setprecision(80) #Sets the precision for the proof.
U‚ÇÄ = load("U0_leaf","U‚ÇÄ") #Leaf solution
N‚ÇÄ = 240    # number of Fourier modes for leaf: 0 ‚â§ n‚ÇÇ ‚â§ n‚ÇÅ ‚â§ N‚ÇÄ for D‚ÇÑ series
N = 180     # number of Fourier modes for operators for the leaf.
d = 22  ; di = interval(d) ; dbig = interval(big(d))   # size of the domain for the leaf
Œª‚ÇÇ = 3.74 ; Œª‚ÇÇi = interval(Œª‚ÇÇ) ; Œª‚ÇÇbig = interval(big(Œª‚ÇÇ)) # values of parameters for the leaf
Œª‚ÇÅ = 0.0566 ; Œª‚ÇÅi = interval(Œª‚ÇÅ) ; Œª‚ÇÅbig = interval(big(Œª‚ÇÅ))
r‚ÇÄ = interval(6e-6) # value of r‚ÇÄ for ùíµ‚ÇÇ

#=U‚ÇÄ = load("U0_ring","U‚ÇÄ") #Ring solution 
N‚ÇÄ = 80   # number of Fourier modes for the ring
N = 60    # number of Fourier modes for operators for the ring
setprecision(80)
d = 10 ; di = interval(d) ; dbig = interval(big(d))   # size of the domain for the ring
Œª‚ÇÇ = 3.73  ; Œª‚ÇÇi = interval(Œª‚ÇÇ) ; Œª‚ÇÇbig = interval(big(Œª‚ÇÇ)) # values of parameters for the ring
Œª‚ÇÅ = 0.0567 ; Œª‚ÇÅi = interval(Œª‚ÇÅ) ; Œª‚ÇÅbig = interval(big(Œª‚ÇÅ))
r‚ÇÄ = interval(6e-6) # value of r‚ÇÄ for ùíµ‚ÇÇ=#

#=U‚ÇÄ = load("U0_spikeaway","U‚ÇÄ") #Spike solution away from Œª‚ÇÅŒª‚ÇÇ = 1
N‚ÇÄ = 50   # number of Fourier modes for the ring
N = 20    # number of Fourier modes for operators for the ring
setprecision(80)
d = 8 ; di = interval(d) ; dbig = interval(big(d))   # size of the domain for the spike away from Œª‚ÇÅŒª‚ÇÇ = 1
Œª‚ÇÇ = 10 ; Œª‚ÇÇi = interval(Œª‚ÇÇ) ; Œª‚ÇÇbig = interval(big(Œª‚ÇÇ)) # values of parameters for the spike away from Œª‚ÇÅŒª‚ÇÇ = 1
Œª‚ÇÅ = 1/9 ; Œª‚ÇÅi = interval(Œª‚ÇÅ) ; Œª‚ÇÅbig = interval(big(Œª‚ÇÅ))
r‚ÇÄ = interval(6e-6) # value of r‚ÇÄ for ùíµ‚ÇÇ=#
U‚ÇÄ‚ÇÅ = component(U‚ÇÄ,1)
U‚ÇÄ‚ÇÇ = component(U‚ÇÄ,2)
fourier_long = D‚ÇÑFourier(N‚ÇÄ,œÄ/di)
fourier = D‚ÇÑFourier(N,œÄ/di)
U‚ÇÄ‚ÇÅ = project(U‚ÇÄ‚ÇÅ,D‚ÇÑFourier(N‚ÇÄ,œÄ/d))
U‚ÇÄ‚ÇÇ = project(U‚ÇÄ‚ÇÇ,D‚ÇÑFourier(N‚ÇÄ,œÄ/d))
print("Creating intervals")
U‚ÇÄ‚ÇÅ_interval = Sequence(fourier_long, interval.(coefficients(U‚ÇÄ‚ÇÅ)))
setprecision(80)
U‚ÇÄ‚ÇÅbig = Sequence(fourier_long, interval.(big.(coefficients(U‚ÇÄ‚ÇÅ))))
U‚ÇÄ‚ÇÇ_interval = Sequence(fourier_long, interval.(coefficients(U‚ÇÄ‚ÇÇ)))
setprecision(80)
U‚ÇÄ‚ÇÇbig = Sequence(fourier_long, interval.(big.(coefficients(U‚ÇÄ‚ÇÇ))))
#################################################   Projection on X¬≤‚ÇÄ   ##################################################################################
# Projection of U‚ÇÄ in X¬≤‚ÇÄ : X‚ÇÄ needs to represent a function in H¬≤‚ÇÄ(Œ©‚ÇÄ) √ó H¬≤‚ÇÄ(Œ©‚ÇÄ)
# We define ùíØ as the trace operator (ùíØU = 0 means that U ‚àà X¬≤‚ÇÄ) and S·µÄ as its adjoint
setprecision(80)
ùíØ = interval.(big.(_trace_D‚ÇÑ(N‚ÇÄ))) ; ùíØ·µÄ = ùíØ'
# We build the operators L·µ¢‚±º and their inverses. We do this as we break things down
# into blocks to avoid memory issues. 
L‚ÇÅ‚ÇÅ = diag(coefficients(project(Laplacian(2), fourier, fourier,Interval{Float64})*Œª‚ÇÅi - I))
L‚ÇÅ‚ÇÅ_long = diag(coefficients(project(Laplacian(2), fourier_long, fourier_long,Interval{Float64})*Œª‚ÇÅi - I))
setprecision(80)
L‚ÇÅ‚ÇÅbig_long = diag(coefficients(project(Laplacian(2), fourier_long, fourier_long,Interval{BigFloat})*Œª‚ÇÅbig - I))

L‚ÇÅ‚ÇÅ‚Åª¬π = interval.(ones(dimension(fourier)))./L‚ÇÅ‚ÇÅ
L‚ÇÅ‚ÇÅ‚Åª¬π_long = interval.(ones(dimension(fourier_long)))./L‚ÇÅ‚ÇÅ_long
L‚ÇÅ‚ÇÅ = Nothing
setprecision(80)
L‚ÇÅ‚ÇÅ‚Åª¬πbig_long = interval.(big.(ones(dimension(fourier_long))))./L‚ÇÅ‚ÇÅbig_long
L‚ÇÅ‚ÇÅbig_long = Nothing

L‚ÇÇ‚ÇÅ = (Œª‚ÇÅi*Œª‚ÇÇi-interval(1))*interval.(ones(dimension(fourier)))
L‚ÇÇ‚ÇÅ_long = (Œª‚ÇÅi*Œª‚ÇÇi-interval(1))*interval.(ones(dimension(fourier_long)))
setprecision(80)
L‚ÇÇ‚ÇÅbig_long = (Œª‚ÇÅbig*Œª‚ÇÇbig-interval(1))*interval.(big.(ones(dimension(fourier_long))))

L‚ÇÇ‚ÇÇ = diag(coefficients(project(Laplacian(2), fourier, fourier,Interval{Float64}) - Œª‚ÇÇi*I))
L‚ÇÇ‚ÇÇ_long = diag(coefficients(project(Laplacian(2), fourier_long, fourier_long,Interval{Float64}) - Œª‚ÇÇi*I))
setprecision(80)
L‚ÇÇ‚ÇÇbig_long = diag(coefficients(project(Laplacian(2), fourier_long, fourier_long,Interval{BigFloat}) - Œª‚ÇÇbig*I))

L‚ÇÇ‚ÇÇ‚Åª¬π = ones(dimension(fourier))./L‚ÇÇ‚ÇÇ
L‚ÇÇ‚ÇÇ‚Åª¬π_long = ones(dimension(fourier_long))./L‚ÇÇ‚ÇÇ_long
L‚ÇÇ‚ÇÇ = Nothing
setprecision(80)
L‚ÇÇ‚ÇÇ‚Åª¬πbig_long = interval.(big.(ones(dimension(fourier_long))))./L‚ÇÇ‚ÇÇbig_long
L‚ÇÇ‚ÇÇbig_long = Nothing

# Finally we can build the projection of U‚ÇÄ on X¬≤‚ÇÄ that we denote U‚ÇÄ again Doing U‚ÇÄ = U‚ÇÄ - L‚Åª¬πS·µÄ(SL‚Åª¬πS·µÄ)‚Åª¬πS
# Note that by expanding the expression above into blocks, we obtain the quantites below
# results for U‚ÇÄ‚ÇÅ and U‚ÇÄ‚ÇÇ
print("Computing the trace")
setprecision(80)
M = solve(Matrix(ùíØ*((L‚ÇÅ‚ÇÅ‚Åª¬πbig_long .- (L‚ÇÇ‚ÇÇ‚Åª¬πbig_long.*L‚ÇÇ‚ÇÅbig_long.*L‚ÇÅ‚ÇÅ‚Åª¬πbig_long) .+ L‚ÇÇ‚ÇÇ‚Åª¬πbig_long).*ùíØ·µÄ)),ùíØ*coefficients(U‚ÇÄ‚ÇÅbig+U‚ÇÄ‚ÇÇbig))
setprecision(80)
U‚ÇÄ‚ÇÅbig = U‚ÇÄ‚ÇÅbig - Sequence(fourier_long,L‚ÇÅ‚ÇÅ‚Åª¬πbig_long.*ùíØ·µÄ*M)
setprecision(80)
U‚ÇÄ‚ÇÇbig = U‚ÇÄ‚ÇÇbig - Sequence(fourier_long,(-(L‚ÇÇ‚ÇÇ‚Åª¬πbig_long.*L‚ÇÇ‚ÇÅbig_long.*L‚ÇÅ‚ÇÅ‚Åª¬πbig_long).*ùíØ'+ L‚ÇÇ‚ÇÇ‚Åª¬πbig_long.*ùíØ')*M)
U‚ÇÄ‚ÇÅ_interval = Interval.(Float64.(inf.(U‚ÇÄ‚ÇÅbig),RoundDown),Float64.(sup.(U‚ÇÄ‚ÇÅbig),RoundUp) )
U‚ÇÄ‚ÇÇ_interval = Interval.(Float64.(inf.(U‚ÇÄ‚ÇÇbig),RoundDown),Float64.(sup.(U‚ÇÄ‚ÇÇbig),RoundUp) )
ùíØ = Nothing
ùíØ·µÄ = Nothing
L‚ÇÅ‚ÇÅ‚Åª¬πbig_long = Nothing
L‚ÇÇ‚ÇÅbig_long = Nothing
L‚ÇÇ‚ÇÇ‚Åª¬πbig_long = Nothing
# # We define an operator P that help us to switch between the D‚ÇÑ and exponential series
# # (as the theoretical analysis is done in exponential series)
# # For a linear operator B between D‚ÇÑ fourier series, P*B*inv(P) gives the equivalent operator
# # on exponential series for the D‚ÇÑ modes (the other modes can be found by computing the orbits of the stored modes)
# # In particular, if B is diagonal, then P*B*inv(P) = B
P = vec(_exp2D‚ÇÑ!(zeros(dimension(fourier)),fourier))
P‚Åª¬π = ones(dimension(fourier))./P
P = interval.(P)
P‚Åª¬π = interval.(P‚Åª¬π)
# Computation of B‚ÇÅ‚ÇÅ,B‚ÇÅ‚ÇÇ and the norm of B‚ÇÅ‚ÇÅ.
print("Computing U‚ÇÄ‚ÇÅ¬≤")
U‚ÇÄ‚ÇÅ¬≤big = U‚ÇÄ‚ÇÅbig*U‚ÇÄ‚ÇÅbig
print("Computing U‚ÇÄ‚ÇÇU‚ÇÄ‚ÇÅ")
U‚ÇÄ‚ÇÇU‚ÇÄ‚ÇÅbig = U‚ÇÄ‚ÇÇbig*U‚ÇÄ‚ÇÅbig
V‚ÇÅbig = interval(2)*U‚ÇÄ‚ÇÇU‚ÇÄ‚ÇÅbig + interval(2)*U‚ÇÄ‚ÇÅbig - interval(3)*Œª‚ÇÅi*U‚ÇÄ‚ÇÅ¬≤big
V‚ÇÇbig = U‚ÇÄ‚ÇÅ¬≤big
U‚ÇÄ‚ÇÅ¬≤_interval = Interval.(Float64.(inf.(U‚ÇÄ‚ÇÅ¬≤big),RoundDown),Float64.(sup.(U‚ÇÄ‚ÇÅ¬≤big),RoundUp) )
V‚ÇÅ_interval = Interval.(Float64.(inf.(V‚ÇÅbig),RoundDown),Float64.(sup.(V‚ÇÅbig),RoundUp) )
V‚ÇÇ_interval = Interval.(Float64.(inf.(V‚ÇÇbig),RoundDown),Float64.(sup.(V‚ÇÇbig),RoundUp) )

DG‚ÇÅ‚ÇÅ = project(Multiplication(V‚ÇÅ_interval),fourier,fourier,Interval{Float64})
DG‚ÇÅ‚ÇÇ = project(Multiplication(V‚ÇÇ_interval),fourier,fourier,Interval{Float64})
print("Computing B")
B‚ÇÅ‚ÇÅ = interval.(inv(mid.(I + DG‚ÇÅ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π' - DG‚ÇÅ‚ÇÇ.*(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π)')))
B‚ÇÅ‚ÇÇ = -B‚ÇÅ‚ÇÅ*DG‚ÇÅ‚ÇÇ.*L‚ÇÇ‚ÇÇ‚Åª¬π'
B‚ÇÅ‚ÇÅ_adjoint = LinearOperator(fourier,fourier, coefficients(B‚ÇÅ‚ÇÅ)')
print("Computing norm of B‚ÇÅ‚ÇÅ")
norm_B‚ÇÅ‚ÇÅ = (opnorm(LinearOperator(coefficients(P.*((B‚ÇÅ‚ÇÅ_adjoint*B‚ÇÅ‚ÇÅ)^2).*P‚Åª¬π')),2))^(interval(1/4))
@show norm_B‚ÇÅ‚ÇÅ

# ################ ùí¥‚ÇÄ BOUND ######################################################
# Computation of the ùí¥‚ÇÄ bound, defined in Lemma 4.3.
print("Computing tail_G‚ÇÅ")
tail_G‚ÇÅ = (U‚ÇÄ‚ÇÇ_interval + interval(1) - Œª‚ÇÅi*U‚ÇÄ‚ÇÅ_interval)*U‚ÇÄ‚ÇÅ¬≤_interval
G‚ÇÅ = project(tail_G‚ÇÅ,fourier)

# These are the components of ùí¥‚ÇÄ expanded. 
# That is, the components of ||(œÄ·¥∫ + BŒ©‚ÇÄ)(LU‚ÇÄ + G(U‚ÇÄ))||‚ÇÇ¬≤.
print("Computing ùí¥‚ÇÄ components")
ùí¥‚ÇÄ¬π = B‚ÇÅ‚ÇÅ*project(L‚ÇÅ‚ÇÅ_long.*U‚ÇÄ‚ÇÅ_interval + G‚ÇÅ,fourier) + B‚ÇÅ‚ÇÇ*project(L‚ÇÇ‚ÇÅ_long.*U‚ÇÄ‚ÇÅ_interval + L‚ÇÇ‚ÇÇ_long.*U‚ÇÄ‚ÇÇ_interval,fourier)
ùí¥‚ÇÄ¬≤ = project(L‚ÇÇ‚ÇÅ_long.*U‚ÇÄ‚ÇÅ_interval + L‚ÇÇ‚ÇÇ_long.*U‚ÇÄ‚ÇÇ_interval,fourier)

# These are the tail components of ùí¥‚ÇÄ as a result of choosing N ‚â† N‚ÇÄ and having a nonlinear term
# That is the components of ||(œÄ¬≥·¥∫‚Å∞ - œÄ·¥∫)LU‚ÇÄ + (œÄ¬≥·¥∫‚Å∞ - œÄ·¥∫)G(U‚ÇÄ)||‚ÇÇ¬≤
ùí¥‚ÇÄ¬π‚àû = L‚ÇÅ‚ÇÅ_long.*(U‚ÇÄ‚ÇÅ_interval - project(U‚ÇÄ‚ÇÅ_interval,fourier))  + tail_G‚ÇÅ - G‚ÇÅ + L‚ÇÇ‚ÇÅ_long.*(U‚ÇÄ‚ÇÅ_interval - project(U‚ÇÄ‚ÇÅ_interval,fourier)) + L‚ÇÇ‚ÇÇ_long.*(U‚ÇÄ‚ÇÇ_interval - project(U‚ÇÄ‚ÇÇ_interval,fourier))
ùí¥‚ÇÄ¬≤‚àû = L‚ÇÇ‚ÇÅ_long.*(U‚ÇÄ‚ÇÅ_interval - project(U‚ÇÄ‚ÇÅ_interval,fourier)) +L‚ÇÇ‚ÇÇ_long.*(U‚ÇÄ‚ÇÇ_interval - project(U‚ÇÄ‚ÇÇ_interval,fourier))

L‚ÇÅ‚ÇÅ_long = Nothing
L‚ÇÇ‚ÇÅ_long = Nothing
L‚ÇÇ‚ÇÇ_long = Nothing

Œ©‚ÇÄ = (2di)^2
ùí¥‚ÇÄ = sqrt(Œ©‚ÇÄ)*sqrt(norm(ùí¥‚ÇÄ¬π,2)^2 + norm(ùí¥‚ÇÄ¬≤,2)^2 + norm(ùí¥‚ÇÄ¬π‚àû,2)^2 + norm(ùí¥‚ÇÄ¬≤‚àû,2)^2)
@show ùí¥‚ÇÄ

################################ ùíµ‚ÇÇ BOUND ######################################################
# Computation of the ùíµ‚ÇÇ bound defined in Lemma 4.5.
# Computation of the constants Œ∫‚ÇÇ,Œ∫‚ÇÉ, and Œ∫‚ÇÄ
print("Computing ùíµ‚ÇÇ")
Œ∫‚ÇÇ = interval(1)/(interval(2)*sqrt(Œª‚ÇÅi*interval(œÄ)))
@show Œ∫‚ÇÇ
Œ∫‚ÇÉ = sqrt(interval(2))/(interval(4œÄ)) * min(interval(1)/(Œª‚ÇÅi*Œª‚ÇÇi),interval(1)/sqrt(Œª‚ÇÅi*Œª‚ÇÇi))
@show Œ∫‚ÇÉ
Œ∫‚ÇÄ = min(max(((Œª‚ÇÅi*Œ∫‚ÇÇ + interval(1)/(interval(2)*sqrt(Œª‚ÇÇi*interval(œÄ))))^2 + interval(1)/(interval(4œÄ)*Œª‚ÇÇi))^(interval(1/2)), sqrt(interval(2))/(interval(2)*sqrt(Œª‚ÇÇi*interval(œÄ)))), Œ∫‚ÇÇ*interval(1)/Œª‚ÇÇi * ((interval(1)-Œª‚ÇÅi*Œª‚ÇÇi)^2 + interval(1))^(interval(1/2)))
@show Œ∫‚ÇÄ
Q = U‚ÇÄ‚ÇÇ_interval + interval(1) -interval(3)*Œª‚ÇÅi*U‚ÇÄ‚ÇÅ_interval
‚Ñö = project(Multiplication(Q),fourier,fourier,Interval{Float64})
ùïå‚ÇÄ‚ÇÅ = project(Multiplication(U‚ÇÄ‚ÇÅ_interval),fourier,fourier,Interval{Float64})
Q¬≤ = Q*Q
‚Ñö¬≤ = project(Multiplication(Q¬≤),fourier,fourier,Interval{Float64})
ùïå‚ÇÄ‚ÇÅ¬≤ = project(Multiplication(U‚ÇÄ‚ÇÅ¬≤_interval),fourier,fourier,Interval{Float64})
print("Computing ùíµ‚ÇÇ‚±º for j = 1,2,3")
ùíµ‚ÇÇ‚ÇÅ = opnorm(LinearOperator(P.*coefficients(B‚ÇÅ‚ÇÅ*(‚Ñö¬≤ + ùïå‚ÇÄ‚ÇÅ¬≤)*B‚ÇÅ‚ÇÅ_adjoint).*P‚Åª¬π'),2)
ùíµ‚ÇÇ‚ÇÇ = sqrt(opnorm(LinearOperator(P.*coefficients(B‚ÇÅ‚ÇÅ*((‚Ñö¬≤+ùïå‚ÇÄ‚ÇÅ¬≤) - (‚Ñö^2 + ùïå‚ÇÄ‚ÇÅ^2))*B‚ÇÅ‚ÇÅ_adjoint).*P‚Åª¬π'),2))
ùíµ‚ÇÇ‚ÇÉ = norm(Q¬≤ + U‚ÇÄ‚ÇÅ¬≤_interval,1)

ùíµ‚ÇÇ = interval(2)*(sqrt(œÜ(ùíµ‚ÇÇ‚ÇÅ,ùíµ‚ÇÇ‚ÇÇ,ùíµ‚ÇÇ‚ÇÇ,ùíµ‚ÇÇ‚ÇÉ))*sqrt(Œ∫‚ÇÇ^2+interval(4)*Œ∫‚ÇÄ^2)) + norm_B‚ÇÅ‚ÇÅ*interval(3)*Œ∫‚ÇÉ*r‚ÇÄ
@show ùíµ‚ÇÇ

################################ ùíµ·µ§‚ÇÅ BOUND ######################################################
# Computation of the ùíµ·µ§‚ÇÅ bound defined in Lemma 4.9.
print("Starting ùíµ·µ§")
setprecision(80)
a‚ÇÅbig = sqrt(interval(1)/Œª‚ÇÅbig)
setprecision(80)
a‚ÇÇbig = sqrt(Œª‚ÇÇbig)
a‚ÇÅ = sqrt(interval(1)/Œª‚ÇÅi)
a‚ÇÇ = sqrt(Œª‚ÇÇi)
# The constants C‚ÇÄf‚ÇÅ‚ÇÅ and C‚ÇÄf‚ÇÇ‚ÇÇ in Lemma 4.8
C‚ÇÄf‚ÇÅ‚ÇÅ = max(a‚ÇÅ^2*interval(interval(2)*exp(interval(5/4)))*(interval(2)/a‚ÇÅ)^(interval(1/4)),a‚ÇÅ^2*sqrt(interval(œÄ)/(interval(2)*sqrt(a‚ÇÅ))))
C‚ÇÄf‚ÇÇ‚ÇÇ = max(interval(interval(2)*exp(interval(5/4)))*(interval(2)/a‚ÇÇ)^(1/4),sqrt(interval(œÄ)/(interval(2)*sqrt(a‚ÇÇ))))
# Computing the fourier series of E‚ÇÅ and E‚ÇÇ defined in Lemma 4.9.
setprecision(80)
E‚ÇÅbig = Sequence(D‚ÇÑFourier(4N,œÄ/di), interval.(big.(zeros(dimension(D‚ÇÑFourier(4N,œÄ/di))))))
setprecision(80)
E‚ÇÇbig = Sequence(D‚ÇÑFourier(4N,œÄ/di), interval.(big.(zeros(dimension(D‚ÇÑFourier(4N,œÄ/di))))))
for n‚ÇÇ = 0:4N
    for n‚ÇÅ = n‚ÇÇ:4N
        setprecision(80)
        E‚ÇÅbig[(n‚ÇÅ,n‚ÇÇ)] = real(interval(big(1))/(interval(big(8))*dbig) * ((-interval(big(1)))^n‚ÇÅ*sinc(n‚ÇÇ)*(interval(big(1))/(interval(big(2))*a‚ÇÅbig-im*n‚ÇÅ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÅbig + im*n‚ÇÅ*interval(big(œÄ))/dbig)) + (-interval(big(1)))^n‚ÇÇ*sinc(n‚ÇÅ)*(interval(big(1))/(interval(big(2))*a‚ÇÅbig-im*n‚ÇÇ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÅbig + im*n‚ÇÇ*interval(big(œÄ))/dbig))))
        setprecision(80)
        E‚ÇÇbig[(n‚ÇÅ,n‚ÇÇ)] = real(interval(big(1))/(interval(big(8))*dbig) * ((-interval(big(1)))^n‚ÇÅ*sinc(n‚ÇÇ)*(interval(big(1))/(interval(big(2))*a‚ÇÇbig-im*n‚ÇÅ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÇbig + im*n‚ÇÅ*interval(big(œÄ))/dbig)) + (-interval(big(1)))^n‚ÇÇ*sinc(n‚ÇÅ)*(interval(big(1))/(interval(big(2))*a‚ÇÇbig-im*n‚ÇÇ*interval(big(œÄ))/dbig) + interval(big(1))/(interval(big(2))*a‚ÇÇbig + im*n‚ÇÇ*interval(big(œÄ))/dbig))))
    end
end
E‚ÇÅ = Interval.(Float64.(inf.(E‚ÇÅbig),RoundDown),Float64.(sup.(E‚ÇÅbig),RoundUp) )
E‚ÇÇ = Interval.(Float64.(inf.(E‚ÇÇbig),RoundDown),Float64.(sup.(E‚ÇÇbig),RoundUp) )
# Computes a larger operator to convert from D‚ÇÑ to exponential since inner products will be of size 2N.
P2 = interval.(vec(_exp2D‚ÇÑ!(zeros(dimension(D‚ÇÑFourier(2N,œÄ/di))),D‚ÇÑFourier(2N,œÄ/di))))

setprecision(80)
P2big = interval.(big.(vec(_exp2D‚ÇÑ!(zeros(dimension(D‚ÇÑFourier(2N,œÄ/di))),D‚ÇÑFourier(2N,œÄ/di)))))

# Computation of the ùíµ·µ§‚ÇÅ‚ÇÅ bound, the first quantity defined in Lemma 4.9.
print("Computing ùíµ·µ§‚ÇÅ‚ÇÅ")
V‚ÇÅ·¥∫_interval = project(V‚ÇÅ_interval,D‚ÇÑFourier(2N,œÄ/di))
V‚ÇÇ·¥∫_interval = project(V‚ÇÇ_interval,D‚ÇÑFourier(2N,œÄ/di))

#For spike and ring, use lines 457 through 461
E‚ÇÅV‚ÇÅ = _conv_small(E‚ÇÅ,V‚ÇÅ·¥∫_interval, 2N)
_inner_prod_E‚ÇÅV‚ÇÅ = abs(coefficients(P2.*V‚ÇÅ·¥∫_interval)'*coefficients(P2.*E‚ÇÅV‚ÇÅ))
@show _inner_prod_E‚ÇÅV‚ÇÅ
ùíµ·µ§‚ÇÅ‚ÇÅ = sqrt(interval(2))*C‚ÇÄf‚ÇÅ‚ÇÅ*(1-exp(-4a‚ÇÅ*di)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÅ^(interval(3/4))*sqrt(Œ©‚ÇÄ) *sqrt(_inner_prod_E‚ÇÅV‚ÇÅ)  
@show ùíµ·µ§‚ÇÅ‚ÇÅ

#For the leaf, use lines 465 through 472
# More specifically, comment lines 457 through 461 and uncommnet lines 465 through 471.
#=setprecision(80)
E‚ÇÅV‚ÇÅbig = _conv_smallbig(E‚ÇÅbig,V‚ÇÅ·¥∫big,2N)
setprecision(80)
_inner_prod_E‚ÇÅV‚ÇÅbig = abs(coefficients(P2big.*V‚ÇÅ·¥∫big)'*coefficients(P2big.*E‚ÇÅV‚ÇÅbig))
@show _inner_prod_E‚ÇÅV‚ÇÅbig
ùíµ·µ§‚ÇÅ‚ÇÅbig = sqrt(interval(2))*C‚ÇÄf‚ÇÅ‚ÇÅ*(1-exp(-4a‚ÇÅ*di)) * (interval(2œÄ))^(1/4)/a‚ÇÅ^(3/4)*sqrt(Œ©‚ÇÄ) *sqrt(_inner_prod_E‚ÇÅV‚ÇÅbig)  
ùíµ·µ§‚ÇÅ‚ÇÅ = Interval(Float64(inf(ùíµ·µ§‚ÇÅ‚ÇÅbig),RoundDown),Float64(sup(ùíµ·µ§‚ÇÅ‚ÇÅbig),RoundUp) )
@show ùíµ·µ§‚ÇÅ‚ÇÅ=#

# Computation of the ùíµ·µ§‚ÇÅ‚ÇÇ bound, the second quantity defined in Lemma 4.9.
print("Computing ùíµ·µ§‚ÇÅ‚ÇÇ")
# For spike and ring, use lines 477 through 481
E‚ÇÇV‚ÇÇ = _conv_small(E‚ÇÇ,V‚ÇÇ·¥∫_interval, 2N)
_inner_prod_E‚ÇÇV‚ÇÇ = abs(coefficients(P2.*V‚ÇÇ·¥∫_interval)'*coefficients(P2.*E‚ÇÇV‚ÇÇ))
@show _inner_prod_E‚ÇÇV‚ÇÇ
ùíµ·µ§‚ÇÅ‚ÇÇ = sqrt(interval(2))*C‚ÇÄf‚ÇÇ‚ÇÇ*(interval(1)-exp(-4a‚ÇÇ*di)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÇ^(interval(3/4))*sqrt(Œ©‚ÇÄ)*sqrt(_inner_prod_E‚ÇÇV‚ÇÇ)  
@show ùíµ·µ§‚ÇÅ‚ÇÇ

# For the leaf, use lines 485 through 492
# More specifically, comment lines 477 through 481 and uncomment 485 through 492.
#=setprecision(80)
E‚ÇÇV‚ÇÇbig = _conv_smallbig(E‚ÇÇbig,V‚ÇÇ·¥∫big,2N)
setprecision(80)
_inner_prod_E‚ÇÇV‚ÇÇbig = abs(coefficients(P2big.*V‚ÇÇ·¥∫big)'*coefficients(P2big.*E‚ÇÇV‚ÇÇbig))
@show _inner_prod_E‚ÇÇV‚ÇÇbig
ùíµ·µ§‚ÇÅ‚ÇÇbig = sqrt(interval(2))*C‚ÇÄf‚ÇÇ‚ÇÇ*(1-exp(-4a‚ÇÇ*di)) * (interval(2œÄ))^(interval(1/4))/a‚ÇÇ^(interval(3/4))*sqrt(Œ©‚ÇÄ)*sqrt(_inner_prod_E‚ÇÇV‚ÇÇbig)  
ùíµ·µ§‚ÇÅ‚ÇÇ = Interval(Float64(inf(ùíµ·µ§‚ÇÅ‚ÇÇbig),RoundDown),Float64(sup(ùíµ·µ§‚ÇÅ‚ÇÇbig),RoundUp) )
@show ùíµ·µ§‚ÇÅ‚ÇÇ=#

#Since 1/Œª‚ÇÅi > Œª‚ÇÇi in all cases we prove, we are in the first case for ùíµ·µ§‚ÇÅ‚ÇÉ, the third expression defined in Lemma 4.8.
ùíµ·µ§‚ÇÅ‚ÇÉ = ùíµ·µ§‚ÇÅ‚ÇÇ  

#Now, we compute the full ùíµ·µ§‚ÇÅ bound concluding the computation of Lemma 4.9.
ùíµ·µ§‚ÇÅ = sqrt((ùíµ·µ§‚ÇÅ‚ÇÅ + ùíµ·µ§‚ÇÅ‚ÇÉ)^2 + ùíµ·µ§‚ÇÅ‚ÇÇ^2)
@show ùíµ·µ§‚ÇÅ
################################ ùíµ·µ§‚ÇÇ BOUND ######################################################
# Computation of the ùíµ·µ§‚ÇÇ bound defined in Lemma 4.10.
# We begin by computing all the necessary constants.
# We start with C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ,C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ,C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ, and C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ defined in Lemma 4.10.
print("Computing ùíµ·µ§‚ÇÇ")
C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ = a‚ÇÅ^3*sqrt(interval(œÄ/2))*interval(1)/sqrt(a‚ÇÅ + interval(1))*(interval(1) + interval(1)/a‚ÇÅ)
C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ = a‚ÇÅ^2*sqrt(interval(œÄ/2))*(sqrt(interval(2))*a‚ÇÅ + interval(1))

C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ = a‚ÇÇ*sqrt(interval(œÄ/2))*1/sqrt(a‚ÇÇ + interval(1))*(interval(1)+interval(1)/a‚ÇÇ)
C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ = sqrt(interval(œÄ/2))*(sqrt(interval(2))*a‚ÇÇ + interval(1))

# Next, we define the constants C‚±º,ùíû‚ÇÅ‚±º, and ùíû‚ÇÇ‚±º for j = 1,2 defined in Lemma 4.10.
C‚ÇÅ = sqrt(di^2/(interval(16)*a‚ÇÅ^2*interval(œÄ)^5) + interval(1)/a‚ÇÅ^4 + di/a‚ÇÅ^3)
C‚ÇÇ = sqrt(di^2/(interval(16)*a‚ÇÇ^2*interval(œÄ)^5) + interval(1)/a‚ÇÇ^4 + di/a‚ÇÇ^3)
ùíû‚ÇÅ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*exp(-a‚ÇÅ*di)*(C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*exp(-a‚ÇÅ) + C‚ÇÅ‚ÇÇf‚ÇÅ‚ÇÅ)/a‚ÇÅ
ùíû‚ÇÇ‚ÇÅ = interval(2)*sqrt(Œ©‚ÇÄ)*C‚ÇÅ‚ÇÅf‚ÇÅ‚ÇÅ*sqrt(log(interval(2))^2 + interval(2)*log(interval(2)) + interval(2))
ùíû‚ÇÅ‚ÇÇ = interval(2)*sqrt(Œ©‚ÇÄ)*exp(-a‚ÇÇ*di)*(C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ*exp(-a‚ÇÇ) + C‚ÇÅ‚ÇÇf‚ÇÇ‚ÇÇ)/a‚ÇÇ
ùíû‚ÇÇ‚ÇÇ = interval(2)*sqrt(Œ©‚ÇÄ)*C‚ÇÅ‚ÇÅf‚ÇÇ‚ÇÇ*sqrt(log(interval(2))^2 + interval(2)*log(interval(2)) + interval(2))

# Now, we compute 1_ùíü‚ÇÄ¬≤ and 1_ùíü‚ÇÄ, the Fourier series representations of the
# characteristic functions on ùíü‚ÇÄ¬≤ and ùíü‚ÇÄ respectively. We do these computations
# using the functions _char_boundary_coeffs and _char_1D_boundary_coeffs.
print("Computing coefficients of characteristic function")
setprecision(80)
char = _char_boundary_coeffs(4N,frequency(U‚ÇÄ‚ÇÅ_interval)[1],dbig)
setprecision(80)
char1D = _char_1D_boundary_coeffs(4N,frequency(U‚ÇÄ‚ÇÅ_interval)[1],dbig)
#Note that the function char is the characteristic function on all four corners.
# Indeed, since V‚±º·¥∫ is D‚ÇÑ-symmetric, we can compute the norm of V‚±º·¥∫ on all four corners
# and divide by 1/4 to obtain the result. For the norm involving ‚àÇ‚Çì‚ÇÅv‚ÇÅ·¥∫, we upper bound
# by the norm in the upper right corner by the norm on all four corners. This allows us
# to compute the convolution of a D‚ÇÑ and D‚ÇÇ sequence, which is less computationally expensive.
# Indeed, (‚àÇ‚Çì‚ÇÅv‚ÇÅ·¥∫)¬≤ is an even (D‚ÇÇ) function.

# Similarly, char1D is the characteristic function of ùíü‚ÇÄ ‚à™ (-d,-d+1). Since v‚ÇÅ·¥∫(d,‚ãÖ)
# is even, we can take the norm on this domain and multiply by 1/2.
P3 = interval.(exp2cos(2N))
P4 = interval.([1 ; sqrt(2)*ones(2N)])

setprecision(80)
V‚ÇÅ·¥∫big = project(V‚ÇÅbig,D‚ÇÑFourier(2N,œÄ/di))
setprecision(80)
·πº‚ÇÅbig = _·πº‚±º_coeffs(V‚ÇÅ·¥∫big)
setprecision(80)
V‚ÇÅ·¥∫dbig = _sequence_on_boundary(V‚ÇÅ·¥∫big)

setprecision(80)
V‚ÇÇ·¥∫big = project(V‚ÇÇbig,D‚ÇÑFourier(2N,œÄ/di))
setprecision(80)
·πº‚ÇÇbig = _·πº‚±º_coeffs(V‚ÇÇ·¥∫big)
setprecision(80)
V‚ÇÇ·¥∫dbig = _sequence_on_boundary(V‚ÇÇ·¥∫big)

char = Interval.(Float64.(inf.(char),RoundDown),Float64.(sup.(char),RoundUp) ) 
char1D = Interval.(Float64.(inf.(char1D),RoundDown),Float64.(sup.(char1D),RoundUp) ) 
·πº‚ÇÅ_interval = Interval.(Float64.(inf.(·πº‚ÇÅbig),RoundDown),Float64.(sup.(·πº‚ÇÅbig),RoundUp) ) 
V‚ÇÅ·¥∫d_interval = Interval.(Float64.(inf.(V‚ÇÅ·¥∫dbig),RoundDown),Float64.(sup.(V‚ÇÅ·¥∫dbig),RoundUp) ) 
·πº‚ÇÇ_interval = Interval.(Float64.(inf.(·πº‚ÇÇbig),RoundDown),Float64.(sup.(·πº‚ÇÇbig),RoundUp) ) 
V‚ÇÇ·¥∫d_interval = Interval.(Float64.(inf.(V‚ÇÇ·¥∫dbig),RoundDown),Float64.(sup.(V‚ÇÇ·¥∫dbig),RoundUp) ) 


# We now compute each ùíµ·µ§‚ÇÇ‚±º bound for  j = 1,2,3. Beginning with ùíµ·µ§‚ÇÇ‚ÇÅ,
print("Computing ùíµ·µ§‚ÇÇ‚ÇÅ")
char·πº‚ÇÅ = __conv_small(char,·πº‚ÇÅ_interval,2N)
_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ = abs(coefficients(P3.*char·πº‚ÇÅ)'*coefficients(P3.*·πº‚ÇÅ_interval))
@show _boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ

charV‚ÇÅ = _conv_small(char,V‚ÇÅ·¥∫_interval,2N)
_boundary_inner_prodV‚ÇÅ = abs(coefficients(P2.*charV‚ÇÅ)'*coefficients(P2.*V‚ÇÅ·¥∫_interval))
@show _boundary_inner_prodV‚ÇÅ

char1DV‚ÇÅd = project(char1D*V‚ÇÅ·¥∫d_interval,space(V‚ÇÅ·¥∫d_interval))
_boundary_inner_prodV‚ÇÅd = abs(coefficients(P4.*char1DV‚ÇÅd)'*coefficients(P4.*V‚ÇÅ·¥∫d_interval))
@show _boundary_inner_prodV‚ÇÅd

CV‚ÇÅ·¥∫ = sqrt(interval(1/8) * sqrt(_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÅ)*sqrt(_boundary_inner_prodV‚ÇÅ) + interval(1)/(2di) * interval(1/4) * _boundary_inner_prodV‚ÇÅd)

ùíµ·µ§‚ÇÇ‚ÇÅ = interval(4)/sqrt(Œ©‚ÇÄ) * C‚ÇÅ * (ùíû‚ÇÅ‚ÇÅ * sqrt(_inner_prod_E‚ÇÅV‚ÇÅ) + ùíû‚ÇÇ‚ÇÅ*CV‚ÇÅ·¥∫)
@show ùíµ·µ§‚ÇÇ‚ÇÅ

# Next, we compute ùíµ·µ§‚ÇÇ‚ÇÇ
print("Computing ùíµ·µ§‚ÇÇ‚ÇÇ")
char·πº‚ÇÇ = __conv_small(char,·πº‚ÇÇ_interval,2N)
_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ = abs(coefficients(P3.*char·πº‚ÇÇ)'*coefficients(P3.*·πº‚ÇÇ_interval))
@show _boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ

charV‚ÇÇ = _conv_small(char,V‚ÇÇ·¥∫_interval,2N)
_boundary_inner_prodV‚ÇÇ = abs(coefficients(P2.*charV‚ÇÇ)'*coefficients(P2.*V‚ÇÇ·¥∫_interval))
@show _boundary_inner_prodV‚ÇÇ

char1DV‚ÇÇd = project(char1D*V‚ÇÇ·¥∫d_interval,space(V‚ÇÇ·¥∫d_interval))
_boundary_inner_prodV‚ÇÇd = abs(coefficients(P4.*char1DV‚ÇÇd)'*coefficients(P4.*V‚ÇÇ·¥∫d_interval))
@show _boundary_inner_prodV‚ÇÇd

CV‚ÇÇ·¥∫ = sqrt(interval(1/8) * sqrt(_boundary_inner_prod‚àÇ‚Çì‚ÇÅV‚ÇÇ)*sqrt(_boundary_inner_prodV‚ÇÇ) + interval(1)/(2di) * interval(1/4) * _boundary_inner_prodV‚ÇÇd)

ùíµ·µ§‚ÇÇ‚ÇÇ = interval(4)/sqrt(Œ©‚ÇÄ) * C‚ÇÇ * (ùíû‚ÇÅ‚ÇÇ * sqrt(_inner_prod_E‚ÇÇV‚ÇÇ) + ùíû‚ÇÇ‚ÇÇ*CV‚ÇÇ·¥∫)
@show ùíµ·µ§‚ÇÇ‚ÇÇ

# Finally, we compute ùíµ·µ§‚ÇÇ‚ÇÉ. Note that we require an additional inner product for its computation.
print("Computing ùíµ·µ§‚ÇÇ‚ÇÉ")
E‚ÇÅV‚ÇÇ = _conv_small(E‚ÇÅ,V‚ÇÇ·¥∫_interval, 2N)
_inner_prod_E‚ÇÅV‚ÇÇ = abs(coefficients(P2.*V‚ÇÇ·¥∫_interval)'*coefficients(P2.*E‚ÇÅV‚ÇÇ))
@show _inner_prod_E‚ÇÅV‚ÇÇ

ùíµ·µ§‚ÇÇ‚ÇÉ =  min(C‚ÇÅ,C‚ÇÇ) *(ùíµ·µ§‚ÇÇ‚ÇÇ/C‚ÇÇ + interval(4)*Œª‚ÇÅi/sqrt(Œ©‚ÇÄ)*(ùíû‚ÇÅ‚ÇÅ * sqrt(_inner_prod_E‚ÇÅV‚ÇÇ) + ùíû‚ÇÇ‚ÇÅ*CV‚ÇÇ·¥∫))
@show ùíµ·µ§‚ÇÇ‚ÇÉ

# Finally, we can compute ùíµ·µ§‚ÇÇ
ùíµ·µ§‚ÇÇ = sqrt((ùíµ·µ§‚ÇÇ‚ÇÅ + ùíµ·µ§‚ÇÇ‚ÇÉ)^2 + ùíµ·µ§‚ÇÇ‚ÇÇ^2)
@show ùíµ·µ§‚ÇÇ

# Now, we define ùíµ·µ§ as
ùíµ·µ§ = sqrt(ùíµ·µ§‚ÇÅ^2 + ùíµ·µ§‚ÇÇ^2)
@show ùíµ·µ§
################################ Z‚ÇÅ BOUND ######################################################
# Computation of the Z‚ÇÅ bound defined in Lemma 4.7.
# The J·µ¢'s are the various computations of the form DG‚ÇÅ‚±ºœÄ‚ÇôDG‚ÇÅ‚Çñ.
# We compute them in advance as we need them multiple times.
print("Computing J·µ¢'s")
V‚ÇÅ·¥∫¬≤_interval = V‚ÇÅ·¥∫_interval*V‚ÇÅ·¥∫_interval
J‚ÇÅ = project(Multiplication(V‚ÇÅ·¥∫¬≤_interval),fourier,fourier) - DG‚ÇÅ‚ÇÅ^2

V‚ÇÇ·¥∫V‚ÇÅ·¥∫_interval = V‚ÇÇ·¥∫_interval*V‚ÇÅ·¥∫_interval
J‚ÇÇ = project(Multiplication(V‚ÇÇ·¥∫V‚ÇÅ·¥∫_interval),fourier,fourier) - DG‚ÇÅ‚ÇÅ*DG‚ÇÅ‚ÇÇ

J‚ÇÉ = project(Multiplication(V‚ÇÇ·¥∫V‚ÇÅ·¥∫_interval),fourier,fourier) - DG‚ÇÅ‚ÇÇ*DG‚ÇÅ‚ÇÅ

V‚ÇÇ·¥∫¬≤_interval = V‚ÇÇ·¥∫_interval*V‚ÇÇ·¥∫_interval
J‚ÇÑ = project(Multiplication(V‚ÇÇ·¥∫¬≤_interval),fourier,fourier) - DG‚ÇÅ‚ÇÇ^2

# Let l·µ¢‚±º‚Çô = min_{n ‚àà J_red(D‚ÇÑ)\I·¥∫} |l·µ¢‚±º(√±)|. Then,
l‚ÇÅ‚ÇÅ‚Çô = ((interval((N+1)œÄ)/di)^2*Œª‚ÇÅi+interval(1))
l‚ÇÇ‚ÇÇ‚Çô = ((interval((N+1)œÄ)/di)^2+Œª‚ÇÇi)
l‚ÇÇ‚ÇÅ‚Çô = abs(Œª‚ÇÅi*Œª‚ÇÇi-interval(1))

# Computation of Z‚ÇÅ‚ÇÉ. Let M‚ÇÉ = œÄ·¥∫(L‚Åª¬π)‚ãÜDG(U‚ÇÄ)‚ãÜœÄ‚ÇôDG(U‚ÇÄ)*L‚Åª¬πœÄ·¥∫
# We fully expand M‚ÇÉ so we can use Lemma 4.1 to estimate its norm.
print("Computing M‚ÇÉ")
M‚ÇÉ‚ÇÅ‚ÇÅ = L‚ÇÅ‚ÇÅ‚Åª¬π.*J‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π' -(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π).*J‚ÇÉ.*L‚ÇÅ‚ÇÅ‚Åª¬π' - L‚ÇÅ‚ÇÅ‚Åª¬π.*J‚ÇÇ.*(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π)' + (L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π).*J‚ÇÑ.*(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π)'
norm_M‚ÇÉ‚ÇÅ‚ÇÅ = opnorm(LinearOperator(coefficients(P.*M‚ÇÉ‚ÇÅ‚ÇÅ.*P‚Åª¬π')),2)
M‚ÇÉ‚ÇÅ‚ÇÅ = Nothing

M‚ÇÉ‚ÇÅ‚ÇÇ = L‚ÇÅ‚ÇÅ‚Åª¬π.*J‚ÇÇ.*L‚ÇÇ‚ÇÇ‚Åª¬π' - (L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π).*J‚ÇÑ.*L‚ÇÇ‚ÇÇ‚Åª¬π'
norm_M‚ÇÉ‚ÇÅ‚ÇÇ = opnorm(LinearOperator(coefficients(P.*M‚ÇÉ‚ÇÅ‚ÇÇ.*P‚Åª¬π')),2)
M‚ÇÉ‚ÇÅ‚ÇÇ = Nothing

M‚ÇÉ‚ÇÇ‚ÇÅ = L‚ÇÇ‚ÇÇ‚Åª¬π.*J‚ÇÉ.*L‚ÇÅ‚ÇÅ‚Åª¬π' - L‚ÇÇ‚ÇÇ‚Åª¬π.*J‚ÇÑ.*(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π)'
norm_M‚ÇÉ‚ÇÇ‚ÇÅ = opnorm(LinearOperator(coefficients(P.*M‚ÇÉ‚ÇÇ‚ÇÅ.*P‚Åª¬π')),2)
M‚ÇÉ‚ÇÇ‚ÇÅ = Nothing

M‚ÇÉ‚ÇÇ‚ÇÇ = L‚ÇÇ‚ÇÇ‚Åª¬π.*J‚ÇÑ.*L‚ÇÇ‚ÇÇ‚Åª¬π'
norm_M‚ÇÉ‚ÇÇ‚ÇÇ = opnorm(LinearOperator(coefficients(P.*M‚ÇÉ‚ÇÇ‚ÇÇ.*P‚Åª¬π')),2)
M‚ÇÉ‚ÇÇ‚ÇÇ = Nothing

Z‚ÇÅ‚ÇÉ = sqrt(œÜ(norm_M‚ÇÉ‚ÇÅ‚ÇÅ,norm_M‚ÇÉ‚ÇÅ‚ÇÇ,norm_M‚ÇÉ‚ÇÇ‚ÇÅ,norm_M‚ÇÉ‚ÇÇ‚ÇÇ))
J‚ÇÇ = Nothing
J‚ÇÉ = Nothing

# Computation of Z‚ÇÅ‚ÇÅ where M‚ÇÑ = œÄ·¥∫(I - BM)œÄ·¥∫(I - M‚ãÜB‚ãÜ)œÄ·¥∫ and M = I + DG*L‚Åª¬π
# By the structure of the system, we only have M‚ÇÅ‚ÇÅ and M‚ÇÅ‚ÇÇ to compute.
print("Computing M‚ÇÑ")
M‚ÇÅ‚ÇÅ = I + DG‚ÇÅ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π' - DG‚ÇÅ‚ÇÇ.*(L‚ÇÇ‚ÇÇ‚Åª¬π.*L‚ÇÇ‚ÇÅ.*L‚ÇÅ‚ÇÅ‚Åª¬π)'
DG‚ÇÅ‚ÇÅ = Nothing
M‚ÇÅ‚ÇÇ = DG‚ÇÅ‚ÇÇ.*L‚ÇÇ‚ÇÇ‚Åª¬π'
DG‚ÇÅ‚ÇÇ = Nothing
M‚ÇÅ‚ÇÅ_adjoint = LinearOperator(fourier,fourier,coefficients(M‚ÇÅ‚ÇÅ)')
M‚ÇÅ‚ÇÇ_adjoint = LinearOperator(fourier,fourier,coefficients(M‚ÇÅ‚ÇÇ)')
B‚ÇÅ‚ÇÅ_adjoint = LinearOperator(fourier,fourier,coefficients(B‚ÇÅ‚ÇÅ)')
B‚ÇÅ‚ÇÇ_adjoint = LinearOperator(fourier,fourier,coefficients(B‚ÇÅ‚ÇÇ)')

# Let M‚ÇÑ = I - BM. Again using the structure of the system, the only nonzero block of M‚ÇÑ is M‚ÇÑ‚ÇÅ‚ÇÅ
M‚ÇÑ‚ÇÅ‚ÇÅ = (I-B‚ÇÅ‚ÇÅ*M‚ÇÅ‚ÇÅ)*(I-M‚ÇÅ‚ÇÅ_adjoint*B‚ÇÅ‚ÇÅ_adjoint) + (B‚ÇÅ‚ÇÅ*M‚ÇÅ‚ÇÇ+B‚ÇÅ‚ÇÇ)*(M‚ÇÅ‚ÇÇ_adjoint*B‚ÇÅ‚ÇÅ_adjoint+B‚ÇÅ‚ÇÇ_adjoint) 
M‚ÇÅ‚ÇÅ = Nothing
M‚ÇÅ‚ÇÅ_adjoint = Nothing
M‚ÇÅ‚ÇÇ = Nothing
M‚ÇÅ‚ÇÇ_adjoint = Nothing
B‚ÇÅ‚ÇÇ = Nothing
B‚ÇÅ‚ÇÇ_adjoint = Nothing

Z‚ÇÅ‚ÇÅ = sqrt(opnorm(LinearOperator(coefficients(P.*M‚ÇÑ‚ÇÅ‚ÇÅ.*P‚Åª¬π')),2))
M‚ÇÑ‚ÇÅ‚ÇÅ = Nothing

# Computation of Z‚ÇÅ‚ÇÇ where 
# M‚ÇÅ = œÄ·¥∫B‚ÇÅ‚ÇÅDG‚ÇÅ‚ÇÅ(U‚ÇÄ)œÄ‚ÇôDG‚ÇÅ‚ÇÅ(U‚ÇÄ)‚ãÜB‚ÇÅ‚ÇÅ‚ãÜœÄ·¥∫ 
# M‚ÇÇ = œÄ·¥∫B‚ÇÅ‚ÇÅDG‚ÇÅ‚ÇÇ(U‚ÇÄ)œÄ‚ÇôDG‚ÇÅ‚ÇÇ(U‚ÇÄ)‚ãÜB‚ÇÅ‚ÇÅ‚ãÜœÄ·¥∫

print("Computing M‚ÇÅ")
M‚ÇÅ = B‚ÇÅ‚ÇÅ*J‚ÇÅ*B‚ÇÅ‚ÇÅ_adjoint
J‚ÇÅ = Nothing
norm_M‚ÇÅ = opnorm(LinearOperator(coefficients(P.*M‚ÇÅ.*P‚Åª¬π')),2)
M‚ÇÅ = Nothing

print("Computing M‚ÇÇ")
M‚ÇÇ = B‚ÇÅ‚ÇÅ*J‚ÇÑ*B‚ÇÅ‚ÇÅ_adjoint
J‚ÇÑ = Nothing
norm_M‚ÇÇ = opnorm(LinearOperator(coefficients(P.*M‚ÇÇ.*P‚Åª¬π')),2)
M‚ÇÇ = Nothing

Z‚ÇÅ‚ÇÇ = sqrt((interval(1)/l‚ÇÅ‚ÇÅ‚Çô * sqrt(norm_M‚ÇÅ) + (l‚ÇÇ‚ÇÅ‚Çô/(l‚ÇÇ‚ÇÇ‚Çô*l‚ÇÅ‚ÇÅ‚Çô))*sqrt(norm_M‚ÇÇ))^2 + interval(1)/l‚ÇÇ‚ÇÇ‚Çô^2*norm_M‚ÇÇ)

# Computation of Z‚ÇÅ‚ÇÑ
print("Computing Z‚ÇÅ‚ÇÑ")
Z‚ÇÅ‚ÇÑ = sqrt((interval(1)/l‚ÇÅ‚ÇÅ‚Çô * norm(V‚ÇÅ·¥∫_interval,1) + (l‚ÇÇ‚ÇÅ‚Çô/(l‚ÇÇ‚ÇÇ‚Çô*l‚ÇÅ‚ÇÅ‚Çô))*norm(V‚ÇÇ·¥∫_interval,1))^2 + interval(1)/l‚ÇÇ‚ÇÇ‚Çô^2*norm(V‚ÇÇ·¥∫_interval,1)^2)

Z‚ÇÅ = œÜ(Z‚ÇÅ‚ÇÅ,Z‚ÇÅ‚ÇÇ,Z‚ÇÅ‚ÇÉ,Z‚ÇÅ‚ÇÑ)

# This computes the error due to taking N ‚â† N‚ÇÄ
inf_error = norm_B‚ÇÅ‚ÇÅ*œÜ(interval(1),0,abs(Œª‚ÇÅi*Œª‚ÇÇi - 1)/Œª‚ÇÇi,1/Œª‚ÇÇi)*sqrt(norm(V‚ÇÅ_interval - V‚ÇÅ·¥∫_interval,1)^2 + norm(V‚ÇÇ_interval - V‚ÇÇ·¥∫_interval,1)^2)

ùíµ‚ÇÅ = Z‚ÇÅ + norm_B‚ÇÅ‚ÇÅ*ùíµ·µ§ + inf_error

r_min = sup((interval(1) - ùíµ‚ÇÅ - sqrt((interval(1) - ùíµ‚ÇÅ)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ))/ùíµ‚ÇÇ)
r_max = min(inf((interval(1) - ùíµ‚ÇÅ + sqrt((interval(1) - ùíµ‚ÇÅ)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ))/ùíµ‚ÇÇ), inf((interval(1)-ùíµ‚ÇÅ)/ùíµ‚ÇÇ))
CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ,ùíµ‚ÇÇ,r‚ÇÄ)


################################ Proof of Periodic Solution #################################################
# The values of Œ∫ÃÇ‚ÇÇ,Œ∫ÃÇ‚ÇÉ, and Œ∫ÃÇ‚ÇÉ defined in Theorem 4.11
Œ∫ÃÇ‚ÇÇ = sqrt(interval(1)/(interval(4œÄ)*Œª‚ÇÅi) + interval(1)/(interval(4)*di^2) + interval(1)/(interval(2)*di) * interval(œÄ)/sqrt(Œª‚ÇÅi))
Œ∫ÃÇ‚ÇÉ = sqrt(interval(2))*min(Œ∫ÃÇ‚ÇÇ^2/Œª‚ÇÇi,Œ∫ÃÇ‚ÇÇ*sqrt(interval(1)/(interval(4œÄ)*Œª‚ÇÇi) + interval(1)/(interval(4)*di^2*Œª‚ÇÇi^2) + interval(1)/(interval(2)*di)*interval(œÄ)/sqrt(Œª‚ÇÇi)))
Œ∫ÃÇ‚ÇÄ‚ÇÅ = sqrt((Œª‚ÇÅi*Œ∫ÃÇ‚ÇÇ + sqrt(interval(1)/(interval(4œÄ)*Œª‚ÇÇi) + interval(1)/(interval(4)*di^2*Œª‚ÇÇi^2) + interval(1)/(interval(2)*di)*interval(œÄ)/sqrt(Œª‚ÇÇi)))^2 + interval(1)/(interval(4œÄ)*Œª‚ÇÇi) + interval(1)/(interval(4)*di^2*Œª‚ÇÇi^2) + interval(1)/(interval(2)*di)*interval(œÄ)/sqrt(Œª‚ÇÇi))
Œ∫ÃÇ‚ÇÄ‚ÇÇ = sqrt(interval(2))*sqrt(interval(1)/(interval(4œÄ)*Œª‚ÇÇi) + interval(1)/(interval(4)*di^2*Œª‚ÇÇi^2) + interval(1)/(interval(2)*di)*interval(œÄ)/sqrt(Œª‚ÇÇi))
Œ∫ÃÇ‚ÇÄ = min(max(Œ∫ÃÇ‚ÇÄ‚ÇÅ,Œ∫ÃÇ‚ÇÄ‚ÇÇ),Œ∫ÃÇ‚ÇÇ*interval(1)/Œª‚ÇÇi * ((interval(1)-Œª‚ÇÅi*Œª‚ÇÇi)^2 + interval(1))^(interval(1/2)))

# We can now perform the computer assisted proof for the branch of periodic solutions
ùíµ‚ÇÅ_hat = ùíµ‚ÇÅ+norm_B‚ÇÅ‚ÇÅ*ùíµ·µ§
ùíµ‚ÇÇ_hat = interval(2)*(sqrt(œÜ(ùíµ‚ÇÇ‚ÇÅ,ùíµ‚ÇÇ‚ÇÇ,ùíµ‚ÇÇ‚ÇÇ,ùíµ‚ÇÇ‚ÇÉ))*sqrt(Œ∫ÃÇ‚ÇÇ^2 + interval(4)*Œ∫ÃÇ‚ÇÄ^2)) + interval(3)*norm_B‚ÇÅ‚ÇÅ*Œ∫ÃÇ‚ÇÉ*r‚ÇÄ
rÃÇ_min = sup((interval(1) - ùíµ‚ÇÅ_hat - sqrt((interval(1) - ùíµ‚ÇÅ_hat)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ_hat))/ùíµ‚ÇÇ_hat)
rÃÇ_max = min(inf((interval(1) - ùíµ‚ÇÅ_hat + sqrt((interval(1) - ùíµ‚ÇÅ_hat)^2 - interval(2)*ùí¥‚ÇÄ*ùíµ‚ÇÇ_hat))/ùíµ‚ÇÇ_hat), inf((interval(1)-ùíµ‚ÇÅ_hat)/ùíµ‚ÇÇ_hat))
CAP(ùí¥‚ÇÄ,ùíµ‚ÇÅ_hat,ùíµ‚ÇÇ_hat,r‚ÇÄ)
